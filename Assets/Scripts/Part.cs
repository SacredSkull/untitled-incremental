using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Linq;

//A part can be bought through the computer to make pc components etc
//For now lets just say all parts are available from the get go, but some will obviously 
//be a little too pricey.

//idea for the future, markets which must be unlocked to get access to parts.
namespace Incremental.XML {

    /**
     * @class   Part
     *
     * @brief   Contains definitions for Parts.
     *          
     * @detail  Parts are requirements for hardware projects. Most will be available to begin with, 
     *          but some may require research or large prices.
     *          
     * @attention      Attainable market tiers will probably be added in place of requiring research to build parts, most likely Market levels being
     *                 research anyway.
     *
     * @author  Conal
     * @author  Peter         
     * 
     * @date    23/03/2015
     */

    public partial class Part : Startable, IComparable<Part> {

        private static List<Part> allparts = new List<Part>();
        private static ObjectIDGenerator _objectID = new ObjectIDGenerator();

        public long ID {
            get {
                bool known;
                return _objectID.GetId(this, out known);
            }
        }

        /**
         * @fn  public static Part getPartByID(int ID)
         *
         * @brief   Gets part by a unique identifier generated by _objectID.
         *
         * @detail  Uses the static member allparts to search for parts, which is filled in the Part() constructor.
         *          If there is more than one part with this ID a warning is logged, and the first found Part
         *          is returned.         
         * 
         * @author  Peter
         * @date    06/04/2015
         *          
         * @warning The current plan for managing parts is to store the amount of parts required in the Part class.
         *          This means that when this method is used to return a Part, it needs to be **cloned** (new object created). 
         *          Otherwise, all projects that depend on that part will have the same amount/overwrite the current amount value. 
         *
         * @param   ID  The identifier.
         *
         * @return  The part identified (or null).
         */

        public static Part getPartByID(int ID) {
            List<Part> temp;
            temp = allparts.Where(x => x.ID == ID).ToList();
            if (temp.Count == 1) {
                return temp[0];
            } else if (temp.Count == 0) {
                return null;
            } else {
                Utility.UnityLog(temp[0].name + " has been defined more than once! The first parsed has been used.", LogLevels.ERROR);
                return temp[0];
            }
        }

        /**
         * @fn  public static Part getPartByName(string name)
         *
         * @brief   Gets part by their name.
         *          
         * @attention   This function converts spaces from the parameter into hyphens (-) - *but nothing else* - and then uses the result as the search string. 
         *              If there is more than one part with this name, a warning is logged, and the first found Part
         *              is returned.
         *              
         * @warning The current plan for managing parts is to store the amount of parts required in the Part class.
         *          This means that when this method is used to return a Part, it needs to be **cloned** (new object created). 
         *          Otherwise, all projects that depend on that part will have the same amount/overwrite the current amount value.
         *
         * @author  Peter
         * @date    06/04/2015
         *
         * @param   name    The name.
         *
         * @return  The part.
         */

        public static Part getPartByName(string name) {
            name = name.Replace(" ", "-");
            List<Part> temp;
            temp = allparts.Where(x => x.name == name).ToList();
            if (temp.Count == 1) {
                return temp[0];
            } else if (temp.Count == 0) {
                return null;
            } else {
                Utility.UnityLog(temp[0].name + " has been defined more than once! The first parsed has been used.", LogLevels.ERROR);
                return temp[0];
            }
        }

        /**
         * @fn  public Part(string name, int amount)
         *
         * @brief   Debugging constructor.
         *          
         * @deprecated  This isn't meant for use other than directly inserting values for testing.
         *              As the Part.xml file populates Part objects, there shouldn't be many real needs to use this.
         *
         * @author  Peter
         * @date    25/03/2015
         *
         * @param   name    The name of the part.
         * @param   amount  The amount.
         */

        public Part(string name, int amount) {
            this.name = name;
            this.number = amount;
        }

        /**
         * @fn  public Part()
         *
         * @brief   Default constructor.
         *          
         * @details A new part will add its self to the static parts list and then create a unique ID that can be used to access it with.
         *
         * @author  Peter
         * @date    25/03/2015
         */

        public Part() {
            allparts.Add(this);

            bool known;
            _objectID.GetId(this, out known);
        }

        //public int numberOwned;

        /**
         * @fn  public void buy(int numberToBuy)
         *
         * @brief   Buy a number of this part.
         *          
         * @deprecated  This method isn't needed anymore because of the changes to dependency management (Now part instances are created
         *              and treated as literal parts - each represents one stock of that type, rather than the type representing your inventory of
         *              that part type).
         *
         * @author  Conal
         * @date    24/03/2015
         *
         * @param   numberToBuy Number to buy.
         */

        public void buy(int numberToBuy) {
            numberOwned += (short)numberToBuy;
        }

        /**
         * @fn  public void use(int numberToUse)
         *
         * @brief   Use a number of this part.
         *          
         * @deprecated  This method isn't needed anymore because of the changes to dependency management (Now part instances are created
         *              and treated as literal parts - each represents one stock of that type, rather than the type representing your inventory of
         *              that part type).
         *
         * @author  Conal
         * @date    24/03/2015
         *
         * @param   numberToUse Number to use.
         */

        public void use(int numberToUse) {
            numberOwned -= (short)numberToUse;
        }

        /**
         * @fn  public int CompareTo(Part b)
         *
         * @brief   Compares this Part (a) object to another (b) to determine their difference.
         *
         * @author  Conal
         * @date    27/03/2015
         *
         * @param   b   Part to compare to this.
         *
         * @return  Negative if this part's cost is less than the other (a < b), 0 if they are equal, or positive if
         *          this part is more expensive than the other (a > b).
         */

        public int CompareTo(Part b) {
            Part a = this;
            if (a.cost == b.cost) {
                return 0;
            } else if (a.cost > b.cost) {
                return 1;
            } else
                return -1;
        }

        /**
         * @fn  public override void complete()
         *
         * @brief   Completes this part(?). Should never have a body!
         *
         * @todo    Evaluate the need for parts to implement Startable- or if Startable should derive a base class that doesn't include these methods.
         * @author  Peter
         * @date    29/03/2015
         */

        public override void complete() {

        }

        /**
         * @fn  public override void abandon()
         *
         * @brief   Abandons this part(?). Should never have a body!
         *          
         * @todo    Evaluate the need for parts to implement Startable- or if Startable should derive a base class that doesn't include these methods.
         *
         * @author  Peter
         * @date    29/03/2015
         */

        public override void abandon() {
            //TODO: This is required by interface Startable
            throw new NotImplementedException();
        }

        /**
         * @fn  public override void start()
         *
         * @brief   Starts this part(?). Should never have a body!
         *          
         * @todo    Evaluate the need for parts to implement Startable- or if Startable should derive a base class that doesn't include these methods.
         *
         * @author  Peter
         * @date    29/03/2015
         */

        public override void start() {
            throw new NotImplementedException();
        }

        /**
         * @property    public override string name
         *
         * @brief   Gets or sets the name.
         *          
         * @detail  The set automatic property converts spaces to hyphens (-).
         *
         * @return  The name.
         */

        public override string name {
            get {
                return this.string_id;
            }
            set {
                this.string_id = value.Replace(" ", "-");
            }
        }

        /**
         * @property    public override int number
         *
         * @brief   Gets or sets the amount.
         *          
         * @deprecated  This property isn't needed anymore because of the changes to dependency management (Now part instances are created
         *              and treated as literal parts - each represents one stock of that type, rather than the type representing your inventory of
         *              that part type).
         *              
         * @warning Strangely this property is an integer, but when set, it actually casts its value to this.amount as a short.
         *
         * @return  The number.
         */

        public override int number {
            get {
                return this.amount;            
            }
            set {
                this.amount = (short)value;
            }
        }

    }
}
