using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Linq;

using Dapper;

using Incremental.Database;

/**
    * @class   Research
    *
    * @brief   Research units are dependencies for projects (and other things).
    *          Research follows a tech tree, and therefore research depends on its parent (or more) research.
    *
    * @author  Conal
    * @author  Peter
    * @date    23/03/2015
    */

public class Research : Startable, IComparable<Research> {
    public int ID { get; set; }
	public string stringID;
	public string description;
	public int cost;
	public int processingLevel = 1;
	//public Research[] prerequisites;
	public bool done;

    /**
        * @fn  public static Research getResearchByID(int ID)
        *
        * @brief   Gets research by a unique identifier generated by _objectID.
        *
        * @detail  Uses the static member allresearch to search for research, which is filled in the Research() constructor.
        *          If there is more than one piece of Research with this ID a warning is logged, and the first found Research
        *          is returned.         
        * 
        * @author  Peter
        * @date    26/03/2015
        *
        * @param   ID  The identifier.
        *
        * @return  The research identified or null, if no research by that ID could be found.
        */

    /**
        * @fn  public static Research getResearchByName(string name)
        *
        * @brief   Gets Research by its name.
        *          
        * @attention   This function converts spaces from the parameter into hyphens (-) - *but nothing else* - and then uses the result as the search string. 
        *              If there is more than one Research with this name, a warning is logged, and the first found Research
        *              is returned.
        *
        * @author  Peter
        * @date    26/03/2015
        *
        * @param   name    The name.
        *
        * @return  The research, or null, if none could be found.
        */

    public override string name {
        get {
            return this.stringID;
        }
        set {
            this.stringID = value;
        }
    }

    /**
        * @property    public List<Startable> Dependencies
        *
        * @brief   Gets the dependencies of this research.
        *          
        * @note    Research only depends on other research.
        *          
        * @detail  Iterates over every dependency for this object and finds the research by it's string name.
        *
        * @return  The list of <Startable> dependencies.
        */

    private List<Research> _Dependencies;

    public List<Research> Dependencies {
        get {
            if (_Dependencies == null) {
                using (DatabaseConnection con = new DatabaseConnection()) {
                    _Dependencies = new List<Research>();
                    const string sql = @"SELECT ID FROM Research as r 
                                INNER JOIN(
	                                SELECT rJunction.ResearchChildID 
	                                FROM Research_Dependencies as rJunction 
	                                WHERE rJunction.ResearchParentID = 3
                                ) as rJunction ON rJunction.ResearchChildID = r.ID;";
                    _Dependencies = con.connection.Query<Research>(sql, new { ID = this.ID }).ToList();
                }
            }
            return _Dependencies;
        }
    }


    public Research(int points){
		this.cost = (short)points;

	}

    /**
        * @fn  public Research()
        *
        * @brief   Default constructor.
        *          
        * @detail  Adds itself to the static list of all created research, then generates a unique ID for this object.
        *
        * @author  Peter
        * @date    26/03/2015
        */

    public Research() {
    }

    /**
        * @fn  public override void complete()
        *
        * @brief   Sets this research as complete.
        *
        * @author  Conal
        * @date    15/03/2015
        */

    public override void complete() {
        done = true;
    }

    /**
        * @fn  public override void abandon()
        *
        * @brief   Abandons this research.
        *
        * @author  Peter
        * @date    29/03/2015
        */

    public override void abandon() {
        //TODO: This is required by interface Startable
        throw new NotImplementedException();
    }

    /**
        * @fn  public override void start()
        *
        * @brief   Starts this research.
        *
        * @author  Peter
        * @date    29/03/2015
        */

    public override void start() {
        //TODO: This is required by interface Startable
        throw new NotImplementedException();
    }

    /**
        * @fn  public int CompareTo(Research b)
        *
        * @brief   Compares this Research object to another to sort which has the higher processing level.
        *
        * @author  Conal
        * @date    20/03/2015
        *
        * @param   b   Research to compare to this.
        *
        * @return  Assuming that **a is this**, and **b is the other** research object:
        *          Negative if this research is smaller (a < b) , 0 if they are equal (a == b), or positive if
        *          this is greater (a > b).
        */

    public int CompareTo(Research b) {
        Research a = this;
        if (a.processingLevel < b.processingLevel) {
            return -1;
        } else if (a.processingLevel > b.processingLevel) {
            return 1;
        } else
            return 0;
    }

        
}
